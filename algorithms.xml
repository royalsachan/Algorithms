<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="algorithms.xsl"?>
 <sorting_algorithms 
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation="algorithms.xsd">
 
 <algorithm>
    <name>Merge Sort</name>
    <inventor>John von Neumann</inventor>
    <year_of_publication>1945</year_of_publication>
    <working_strategy>Divides the array into two halves, recursively sorts them, and then merges the two sorted halves.</working_strategy>
    <time_complexity>
      <best>O(n log n)</best>
      <average>O(n log n)</average>
      <worst>O(n log n)</worst>
    </time_complexity>
    <space_complexity>O(n)</space_complexity>
    <suitable_for>Large datasets, external sorting</suitable_for>
    <stability>Stable</stability>
  </algorithm>

  <algorithm>
    <name>Insertion Sort</name>
    <inventor>Unknown</inventor>
    <year_of_publication>1950s</year_of_publication>
    <working_strategy>Builds the final sorted array one item at a time, by iteratively inserting elements into their correct position.</working_strategy>
    <time_complexity>
      <best>O(n)</best>
      <average>O(n^2)</average>
      <worst>O(n^2)</worst>
    </time_complexity>
    <space_complexity>O(1)</space_complexity>
    <suitable_for>Small datasets, partially sorted arrays</suitable_for>
    <stability>Stable</stability>
  </algorithm>

  <algorithm>
    <name>Selection Sort</name>
    <inventor>Unknown</inventor>
    <year_of_publication>1950s</year_of_publication>
    <working_strategy>Repeatedly selects the smallest (or largest) element from the unsorted portion and moves it to the sorted portion.</working_strategy>
    <time_complexity>
      <best>O(n^2)</best>
      <average>O(n^2)</average>
      <worst>O(n^2)</worst>
    </time_complexity>
    <space_complexity>O(1)</space_complexity>
    <suitable_for>Small datasets, minimizing memory writes</suitable_for>
    <stability>Unstable</stability>
  </algorithm>

  <algorithm>
    <name>Heap Sort</name>
    <inventor>J. W. J. Williams</inventor>
    <year_of_publication>1964</year_of_publication>
    <working_strategy>Creates a heap data structure and repeatedly extracts the maximum element to build the sorted array.</working_strategy>
    <time_complexity>
      <best>O(n log n)</best>
      <average>O(n log n)</average>
      <worst>O(n log n)</worst>
    </time_complexity>
    <space_complexity>O(1)</space_complexity>
    <suitable_for>Large datasets, systems with memory constraints</suitable_for>
    <stability>Unstable</stability>
  </algorithm>

  <algorithm>
    <name>Counting Sort</name>
    <inventor>Harold H. Seward</inventor>
    <year_of_publication>1954</year_of_publication>
    <working_strategy>Counts the number of objects with distinct key values, and uses arithmetic to determine the positions of each key value in the output sequence.</working_strategy>
    <time_complexity>
      <best>O(n+k)</best>
      <average>O(n+k)</average>
      <worst>O(n+k)</worst>
    </time_complexity>
    <space_complexity>O(k)</space_complexity>
    <suitable_for>Integer sorting with small range</suitable_for>
    <stability>Stable</stability>
  </algorithm>

  <algorithm>
    <name>Radix Sort</name>
    <inventor>Harold H. Seward</inventor>
    <year_of_publication>1954</year_of_publication>
    <working_strategy>Sorts the elements by processing each digit or character position, starting from the least significant digit to the most significant digit.</working_strategy>
    <time_complexity>
      <best>O(nk)</best>
      <average>O(nk)</average>
      <worst>O(nk)</worst>
    </time_complexity>
    <space_complexity>O(n+k)</space_complexity>
    <suitable_for>Integer and string sorting</suitable_for>
    <stability>Stable</stability>
  </algorithm>

  <algorithm>
    <name>Bucket Sort</name>
    <inventor>Unknown</inventor>
    <year_of_publication>Unknown</year_of_publication>
    <working_strategy>Distributes the elements into a number of buckets, then sorts each bucket individually, often using a different sorting algorithm or by recursively applying bucket sort.</working_strategy>
    <time_complexity>
      <best>O(n+k)</best>
      <average>O(n+k)</average>
      <worst>O(n^2)</worst>
    </time_complexity>
    <space_complexity>O(n+k)</space_complexity>
    <suitable_for>Uniformly distributed data over a range</suitable_for>
    <stability>Stable</stability>
  </algorithm>

  <algorithm>
    <name>Shell Sort</name>
    <inventor>Donald Shell</inventor>
    <year_of_publication>1959</year_of_publication>
    <working_strategy>Improves upon insertion sort by comparing elements separated by a gap and gradually reducing the gap.</working_strategy>
    <time_complexity>
      <best>O(n log n)</best>
      <average>Depends on gap sequence</average>
      <worst>O(n^2)</worst>
    </time_complexity>
    <space_complexity>O(1)</space_complexity>
    <suitable_for>Medium-sized datasets</suitable_for>
    <stability>Unstable</stability>
  </algorithm>
  
   <algorithm>
    <name>Tim Sort</name>
    <inventor>Tim Peters</inventor>
    <year_of_publication>2002</year_of_publication>
    <working_strategy>A hybrid sorting algorithm derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data.</working_strategy>
    <time_complexity>
      <best>O(n)</best>
      <average>O(n log n)</average>
      <worst>O(n log n)</worst>
    </time_complexity>
    <space_complexity>O(n)</space_complexity>
    <suitable_for>Real-world data, partially ordered arrays</suitable_for>
    <stability>Stable</stability>
  </algorithm>

  <algorithm>
    <name>Cocktail Shaker Sort</name>
    <inventor>Unknown</inventor>
    <year_of_publication>Unknown</year_of_publication>
    <working_strategy>A variation of bubble sort that sorts in both directions on each pass through the list.</working_strategy>
    <time_complexity>
      <best>O(n)</best>
      <average>O(n^2)</average>
      <worst>O(n^2)</worst>
    </time_complexity>
    <space_complexity>O(1)</space_complexity>
    <suitable_for>Small datasets, nearly sorted lists</suitable_for>
    <stability>Stable</stability>
  </algorithm>

  <algorithm>
    <name>Comb Sort</name>
    <inventor>WÅ‚odzimierz Dobosiewicz</inventor>
    <year_of_publication>1980</year_of_publication>
    <working_strategy>Improves on bubble sort by using gap sequence to eliminate turtles, or small values near the end of the list.</working_strategy>
    <time_complexity>
      <best>O(n log n)</best>
      <average>O(n^2/2^p)</average>
      <worst>O(n^2)</worst>
    </time_complexity>
    <space_complexity>O(1)</space_complexity>
    <suitable_for>Medium-sized datasets, improvement over bubble sort</suitable_for>
    <stability>Unstable</stability>
  </algorithm>
  
</sorting_algorithms>
